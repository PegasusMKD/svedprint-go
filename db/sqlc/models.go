// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package sqlc

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type AcademicLevel string

const (
	AcademicLevelFirstYear  AcademicLevel = "first_year"
	AcademicLevelSecondYear AcademicLevel = "second_year"
	AcademicLevelJuniorYear AcademicLevel = "junior_year"
	AcademicLevelSeniorYear AcademicLevel = "senior_year"
)

func (e *AcademicLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AcademicLevel(s)
	case string:
		*e = AcademicLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for AcademicLevel: %T", src)
	}
	return nil
}

type NullAcademicLevel struct {
	AcademicLevel AcademicLevel
	Valid         bool // Valid is true if AcademicLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAcademicLevel) Scan(value interface{}) error {
	if value == nil {
		ns.AcademicLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AcademicLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAcademicLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AcademicLevel), nil
}

type BehaviourType string

const (
	BehaviourTypeExemplary BehaviourType = "exemplary"
)

func (e *BehaviourType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BehaviourType(s)
	case string:
		*e = BehaviourType(s)
	default:
		return fmt.Errorf("unsupported scan type for BehaviourType: %T", src)
	}
	return nil
}

type NullBehaviourType struct {
	BehaviourType BehaviourType
	Valid         bool // Valid is true if BehaviourType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBehaviourType) Scan(value interface{}) error {
	if value == nil {
		ns.BehaviourType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BehaviourType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBehaviourType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BehaviourType), nil
}

type Gender string

const (
	GenderMale    Gender = "male"
	GenderFemale  Gender = "female"
	GenderUnknown Gender = "unknown"
)

func (e *Gender) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Gender(s)
	case string:
		*e = Gender(s)
	default:
		return fmt.Errorf("unsupported scan type for Gender: %T", src)
	}
	return nil
}

type NullGender struct {
	Gender Gender
	Valid  bool // Valid is true if Gender is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGender) Scan(value interface{}) error {
	if value == nil {
		ns.Gender, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Gender.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGender) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Gender), nil
}

type SchoolType string

const (
	SchoolTypeGymnasium    SchoolType = "gymnasium"
	SchoolTypeProfessional SchoolType = "professional"
)

func (e *SchoolType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SchoolType(s)
	case string:
		*e = SchoolType(s)
	default:
		return fmt.Errorf("unsupported scan type for SchoolType: %T", src)
	}
	return nil
}

type NullSchoolType struct {
	SchoolType SchoolType
	Valid      bool // Valid is true if SchoolType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSchoolType) Scan(value interface{}) error {
	if value == nil {
		ns.SchoolType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SchoolType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSchoolType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SchoolType), nil
}

type StudyType string

const (
	StudyTypeRegular   StudyType = "regular"
	StudyTypeIrregular StudyType = "irregular"
)

func (e *StudyType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StudyType(s)
	case string:
		*e = StudyType(s)
	default:
		return fmt.Errorf("unsupported scan type for StudyType: %T", src)
	}
	return nil
}

type NullStudyType struct {
	StudyType StudyType
	Valid     bool // Valid is true if StudyType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStudyType) Scan(value interface{}) error {
	if value == nil {
		ns.StudyType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StudyType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStudyType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StudyType), nil
}

type SubjectOrientations string

const (
	SubjectOrientationsGeneral SubjectOrientations = "general"
	SubjectOrientationsPma     SubjectOrientations = "pma"
	SubjectOrientationsPmb     SubjectOrientations = "pmb"
)

func (e *SubjectOrientations) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubjectOrientations(s)
	case string:
		*e = SubjectOrientations(s)
	default:
		return fmt.Errorf("unsupported scan type for SubjectOrientations: %T", src)
	}
	return nil
}

type NullSubjectOrientations struct {
	SubjectOrientations SubjectOrientations
	Valid               bool // Valid is true if SubjectOrientations is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubjectOrientations) Scan(value interface{}) error {
	if value == nil {
		ns.SubjectOrientations, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubjectOrientations.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubjectOrientations) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubjectOrientations), nil
}

type YearSuccessType string

const (
	YearSuccessTypeExcellent      YearSuccessType = "excellent"
	YearSuccessTypeGood           YearSuccessType = "good"
	YearSuccessTypeFair           YearSuccessType = "fair"
	YearSuccessTypeUnsatisfactory YearSuccessType = "unsatisfactory"
	YearSuccessTypeFail           YearSuccessType = "fail"
)

func (e *YearSuccessType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = YearSuccessType(s)
	case string:
		*e = YearSuccessType(s)
	default:
		return fmt.Errorf("unsupported scan type for YearSuccessType: %T", src)
	}
	return nil
}

type NullYearSuccessType struct {
	YearSuccessType YearSuccessType
	Valid           bool // Valid is true if YearSuccessType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullYearSuccessType) Scan(value interface{}) error {
	if value == nil {
		ns.YearSuccessType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.YearSuccessType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullYearSuccessType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.YearSuccessType), nil
}

type AcademicYear struct {
	SchoolUuid       pgtype.UUID
	YearRange        string
	SchoolType       SchoolType
	LastDigitsOfYear string
	ActNumber        pgtype.Text
	ActDate          pgtype.Date
}

type School struct {
	Uuid           pgtype.UUID
	SchoolName     string
	DirectorName   pgtype.Text
	BusinessNumber pgtype.Text
	MainBook       pgtype.Text
	Ministry       pgtype.Text
	Country        pgtype.Text
	City           pgtype.Text
}

type SchoolClass struct {
	Uuid                      pgtype.UUID
	AcademicLevel             NullAcademicLevel
	Suffix                    pgtype.Text
	AcademicYearUuid          pgtype.UUID
	ResponsibleTeacherUuid    pgtype.UUID
	DefaultSubjectPackageUuid pgtype.UUID
}

type SchoolDiplomaDetail struct {
	Uuid             pgtype.UUID
	AcademicYearUuid pgtype.UUID
	PrintDate        pgtype.Date
}

type SchoolTestimonyDetail struct {
	Uuid             pgtype.UUID
	AcademicYearUuid pgtype.UUID
	TestimonyDate    pgtype.Date
}

type Student struct {
	Uuid             pgtype.UUID
	FirstName        pgtype.Text
	MiddleName       pgtype.Text
	LastName         pgtype.Text
	PersonalNumber   pgtype.Text
	FathersName      pgtype.Text
	MothersName      pgtype.Text
	DateOfBirth      pgtype.Date
	PlaceOfResidence pgtype.Text
	PlaceOfBirth     pgtype.Text
	Citizenship      pgtype.Text
	SchoolUuid       pgtype.UUID
}

type StudentsYearlyDetail struct {
	Uuid                      pgtype.UUID
	StudentUuid               pgtype.UUID
	AcademicLevel             AcademicLevel
	NumberInClass             pgtype.Int4
	TakenExam                 bool
	PassedExam                bool
	PassedYear                bool
	JustifiedAbsences         int32
	UnjustifiedAbsences       int32
	BehaviourType             BehaviourType
	PrimtedTestimony          bool
	TestimonyPrintDate        pgtype.Date
	BusinessNumber            pgtype.Date
	DiplomaBusinessNumber     pgtype.Text
	InitialSubjectPackageUuid pgtype.UUID
	SchoolClassUuid           pgtype.UUID
	AcademicYearUuid          pgtype.UUID
}

type StudentsYearlyOptionalSubject struct {
	Uuid                 pgtype.UUID
	StudentsYearlyDetail pgtype.UUID
}

type Subject struct {
	Uuid          pgtype.UUID
	ShortName     pgtype.Text
	FullName      pgtype.Text
	AcademicLevel AcademicLevel
	SchoolUuid    pgtype.UUID
}

type SubjectPackage struct {
	Uuid             pgtype.UUID
	ShortName        pgtype.Text
	FullName         pgtype.Text
	AcademicLevel    AcademicLevel
	AcademicYearUuid pgtype.UUID
}

type SubjectPackageSubject struct {
	Uuid               pgtype.UUID
	SubjectUuid        pgtype.UUID
	SubjectPackageUuid pgtype.UUID
}

type Teacher struct {
	Uuid         pgtype.UUID
	SchoolUuid   pgtype.UUID
	FirstName    string
	MiddleName   pgtype.Text
	LastName     string
	Username     string
	Password     string
	PrintAllowed bool
}
