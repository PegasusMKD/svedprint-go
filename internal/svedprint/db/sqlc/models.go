// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package sqlc

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type AcademicLevel string

const (
	AcademicLevelFirstYear  AcademicLevel = "first_year"
	AcademicLevelSecondYear AcademicLevel = "second_year"
	AcademicLevelJuniorYear AcademicLevel = "junior_year"
	AcademicLevelSeniorYear AcademicLevel = "senior_year"
)

func (e *AcademicLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AcademicLevel(s)
	case string:
		*e = AcademicLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for AcademicLevel: %T", src)
	}
	return nil
}

type NullAcademicLevel struct {
	AcademicLevel AcademicLevel
	Valid         bool // Valid is true if AcademicLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAcademicLevel) Scan(value interface{}) error {
	if value == nil {
		ns.AcademicLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AcademicLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAcademicLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AcademicLevel), nil
}

type BehaviourType string

const (
	BehaviourTypeExemplary BehaviourType = "exemplary"
)

func (e *BehaviourType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BehaviourType(s)
	case string:
		*e = BehaviourType(s)
	default:
		return fmt.Errorf("unsupported scan type for BehaviourType: %T", src)
	}
	return nil
}

type NullBehaviourType struct {
	BehaviourType BehaviourType
	Valid         bool // Valid is true if BehaviourType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBehaviourType) Scan(value interface{}) error {
	if value == nil {
		ns.BehaviourType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BehaviourType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBehaviourType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BehaviourType), nil
}

type Gender string

const (
	GenderMale    Gender = "male"
	GenderFemale  Gender = "female"
	GenderUnknown Gender = "unknown"
)

func (e *Gender) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Gender(s)
	case string:
		*e = Gender(s)
	default:
		return fmt.Errorf("unsupported scan type for Gender: %T", src)
	}
	return nil
}

type NullGender struct {
	Gender Gender
	Valid  bool // Valid is true if Gender is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGender) Scan(value interface{}) error {
	if value == nil {
		ns.Gender, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Gender.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGender) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Gender), nil
}

type StudyType string

const (
	StudyTypeRegular   StudyType = "regular"
	StudyTypeIrregular StudyType = "irregular"
)

func (e *StudyType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StudyType(s)
	case string:
		*e = StudyType(s)
	default:
		return fmt.Errorf("unsupported scan type for StudyType: %T", src)
	}
	return nil
}

type NullStudyType struct {
	StudyType StudyType
	Valid     bool // Valid is true if StudyType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStudyType) Scan(value interface{}) error {
	if value == nil {
		ns.StudyType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StudyType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStudyType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StudyType), nil
}

type YearSuccessType string

const (
	YearSuccessTypeExcellent      YearSuccessType = "excellent"
	YearSuccessTypeGood           YearSuccessType = "good"
	YearSuccessTypeFair           YearSuccessType = "fair"
	YearSuccessTypeUnsatisfactory YearSuccessType = "unsatisfactory"
	YearSuccessTypeFail           YearSuccessType = "fail"
)

func (e *YearSuccessType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = YearSuccessType(s)
	case string:
		*e = YearSuccessType(s)
	default:
		return fmt.Errorf("unsupported scan type for YearSuccessType: %T", src)
	}
	return nil
}

type NullYearSuccessType struct {
	YearSuccessType YearSuccessType
	Valid           bool // Valid is true if YearSuccessType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullYearSuccessType) Scan(value interface{}) error {
	if value == nil {
		ns.YearSuccessType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.YearSuccessType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullYearSuccessType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.YearSuccessType), nil
}

type Student struct {
	Uuid             pgtype.UUID
	FirstName        pgtype.Text
	MiddleName       pgtype.Text
	LastName         pgtype.Text
	PersonalNumber   pgtype.Text
	FathersName      pgtype.Text
	MothersName      pgtype.Text
	DateOfBirth      pgtype.Date
	PlaceOfResidence pgtype.Text
	PlaceOfBirth     pgtype.Text
	Citizenship      pgtype.Text
	SchoolUuid       pgtype.UUID
}

type StudentsYearlyDetail struct {
	Uuid                      pgtype.UUID
	StudentUuid               pgtype.UUID
	AcademicLevel             AcademicLevel
	NumberInClass             pgtype.Int4
	TakenExam                 bool
	PassedExam                bool
	PassedYear                bool
	JustifiedAbsences         int32
	UnjustifiedAbsences       int32
	BehaviourType             BehaviourType
	PrimtedTestimony          bool
	TestimonyPrintDate        pgtype.Date
	BusinessNumber            pgtype.Date
	DiplomaBusinessNumber     pgtype.Text
	InitialSubjectPackageUuid pgtype.UUID
	SchoolClassUuid           pgtype.UUID
	AcademicYearUuid          pgtype.UUID
}

type StudentsYearlyOptionalSubject struct {
	Uuid                 pgtype.UUID
	StudentsYearlyDetail pgtype.UUID
	SubjectUuid          pgtype.UUID
}
