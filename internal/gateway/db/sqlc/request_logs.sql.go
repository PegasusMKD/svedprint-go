// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: request_logs.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchInsertRequestLogsParams struct {
	Timestamp       pgtype.Timestamptz
	Method          string
	IncomingPath    string
	RedirectedPath  pgtype.Text
	UserID          pgtype.Text
	Realm           pgtype.Text
	StatusCode      int32
	ResponseTimeMs  int32
	UpstreamService pgtype.Text
	ErrorMessage    pgtype.Text
}

const getRecentErrorLogs = `-- name: GetRecentErrorLogs :many
select id, timestamp, method, incoming_path, redirected_path, user_id, realm, status_code, response_time_ms, upstream_service, error_message, created_at from request_logs
where status_code >= 400
order by timestamp desc
limit $1
`

func (q *Queries) GetRecentErrorLogs(ctx context.Context, limitCount int32) ([]RequestLog, error) {
	rows, err := q.db.Query(ctx, getRecentErrorLogs, limitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RequestLog
	for rows.Next() {
		var i RequestLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Method,
			&i.IncomingPath,
			&i.RedirectedPath,
			&i.UserID,
			&i.Realm,
			&i.StatusCode,
			&i.ResponseTimeMs,
			&i.UpstreamService,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestLogsByService = `-- name: GetRequestLogsByService :many
select id, timestamp, method, incoming_path, redirected_path, user_id, realm, status_code, response_time_ms, upstream_service, error_message, created_at from request_logs
where upstream_service = $1
order by timestamp desc
limit $2
`

type GetRequestLogsByServiceParams struct {
	UpstreamService pgtype.Text
	LimitCount      int32
}

func (q *Queries) GetRequestLogsByService(ctx context.Context, arg GetRequestLogsByServiceParams) ([]RequestLog, error) {
	rows, err := q.db.Query(ctx, getRequestLogsByService, arg.UpstreamService, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RequestLog
	for rows.Next() {
		var i RequestLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Method,
			&i.IncomingPath,
			&i.RedirectedPath,
			&i.UserID,
			&i.Realm,
			&i.StatusCode,
			&i.ResponseTimeMs,
			&i.UpstreamService,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestLogsByTimeRange = `-- name: GetRequestLogsByTimeRange :many
select id, timestamp, method, incoming_path, redirected_path, user_id, realm, status_code, response_time_ms, upstream_service, error_message, created_at from request_logs
where timestamp between $1 and $2
order by timestamp desc
`

type GetRequestLogsByTimeRangeParams struct {
	StartTime pgtype.Timestamptz
	EndTime   pgtype.Timestamptz
}

func (q *Queries) GetRequestLogsByTimeRange(ctx context.Context, arg GetRequestLogsByTimeRangeParams) ([]RequestLog, error) {
	rows, err := q.db.Query(ctx, getRequestLogsByTimeRange, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RequestLog
	for rows.Next() {
		var i RequestLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Method,
			&i.IncomingPath,
			&i.RedirectedPath,
			&i.UserID,
			&i.Realm,
			&i.StatusCode,
			&i.ResponseTimeMs,
			&i.UpstreamService,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestLogsByUser = `-- name: GetRequestLogsByUser :many
select id, timestamp, method, incoming_path, redirected_path, user_id, realm, status_code, response_time_ms, upstream_service, error_message, created_at from request_logs
where user_id = $1
order by timestamp desc
limit $2
`

type GetRequestLogsByUserParams struct {
	UserID     pgtype.Text
	LimitCount int32
}

func (q *Queries) GetRequestLogsByUser(ctx context.Context, arg GetRequestLogsByUserParams) ([]RequestLog, error) {
	rows, err := q.db.Query(ctx, getRequestLogsByUser, arg.UserID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RequestLog
	for rows.Next() {
		var i RequestLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Method,
			&i.IncomingPath,
			&i.RedirectedPath,
			&i.UserID,
			&i.Realm,
			&i.StatusCode,
			&i.ResponseTimeMs,
			&i.UpstreamService,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRequestLog = `-- name: InsertRequestLog :exec
insert into request_logs (
    timestamp,
    method,
    incoming_path,
    redirected_path,
    user_id,
    realm,
    status_code,
    response_time_ms,
    upstream_service,
    error_message
) values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
`

type InsertRequestLogParams struct {
	Timestamp       pgtype.Timestamptz
	Method          string
	IncomingPath    string
	RedirectedPath  pgtype.Text
	UserID          pgtype.Text
	Realm           pgtype.Text
	StatusCode      int32
	ResponseTimeMs  int32
	UpstreamService pgtype.Text
	ErrorMessage    pgtype.Text
}

func (q *Queries) InsertRequestLog(ctx context.Context, arg InsertRequestLogParams) error {
	_, err := q.db.Exec(ctx, insertRequestLog,
		arg.Timestamp,
		arg.Method,
		arg.IncomingPath,
		arg.RedirectedPath,
		arg.UserID,
		arg.Realm,
		arg.StatusCode,
		arg.ResponseTimeMs,
		arg.UpstreamService,
		arg.ErrorMessage,
	)
	return err
}
